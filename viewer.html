<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Simple WebRTC Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; padding:18px; background:#f3f4f8; color:#222; }
    h2 { margin-top:0; }
    #videos { display:flex; gap:12px; flex-wrap:wrap; }
    .tile { display:flex; flex-direction:column; gap:6px; align-items:flex-start; }
    video { width:480px; height:270px; background:#000; border-radius:6px; display:block; }
    #log { margin-top:12px; background:#111; color:#ddd; padding:8px; border-radius:6px; max-height:220px; overflow:auto; font-family:monospace; font-size:12px; }
    button { margin-right:8px; padding:8px 10px; border-radius:6px; }
  </style>
</head>
<body>
  <h2>Simple WebRTC Viewer</h2>
  <div>Status: <span id="status">idle</span></div>
  <div style="margin-top:10px;">
    <button id="btnReconnect">Reconnect</button>
    <button id="btnUnmute">Unmute All</button>
  </div>
  <div id="videos"></div>
  <pre id="log"></pre>

<script>
const SIGNALING_URL = "wss://camera-relay.onrender.com/ws/viewer1";
const VIEWER_ID = "viewer1";
const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];

let pc = null;
let ws = null;
let broadcasterId = null;
let localCandidateQueue = [];

const logEl = document.getElementById('log');
function log(msg) {
  const t = new Date().toLocaleTimeString();
  logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent;
  document.getElementById('status').textContent = msg.split('\n')[0];
  console.log(msg);
}

function createPeerConnection(){
  if (pc && pc.connectionState !== "closed") {
    try { pc.close(); } catch(e) {}
  }
  pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

  pc.oniceconnectionstatechange = () => log("ICE state: " + pc.iceConnectionState);
  pc.onconnectionstatechange = () => log("Connection state: " + pc.connectionState);
  pc.onsignalingstatechange = () => log("Signaling state: " + pc.signalingState);

  pc.ontrack = (event) => {
    const trackId = event.track.id || (event.track.label || ("track-" + (document.querySelectorAll('.tile').length+1)));
    let tile = document.getElementById('tile-' + trackId);
    if (!tile) {
      tile = document.createElement('div');
      tile.id = 'tile-' + trackId;
      tile.className = 'tile';
      const caption = document.createElement('div');
      caption.textContent = event.track.label || trackId;
      const video = document.createElement('video');
      video.id = 'vid-' + trackId;
      video.autoplay = true;
      video.playsInline = true;
      video.muted = true; // start muted to allow autoplay
      video.controls = true;

      tile.appendChild(caption);
      tile.appendChild(video);
      document.getElementById('videos').appendChild(tile);

      // attach stream if provided
      if (event.streams && event.streams[0]) {
        video.srcObject = event.streams[0];
      } else {
        const ms = new MediaStream();
        ms.addTrack(event.track);
        video.srcObject = ms;
      }

      video.play().catch(e => log("video.play() rejected: " + e.message));
      log(`Created tile for track id=${trackId} label=${event.track.label || 'N/A'}`);
    } else {
      const video = tile.querySelector('video');
      if (event.streams && event.streams[0]) {
        video.srcObject = event.streams[0];
      } else {
        const ms = new MediaStream();
        ms.addTrack(event.track);
        video.srcObject = ms;
      }
      log(`Updated tile for track id=${trackId}`);
    }
  };

  pc.onicecandidate = (ev) => {
    const c = ev.candidate;
    const payload = {
      type: "ice",
      from: VIEWER_ID,
      to: broadcasterId || null,
      candidate: c ? { candidate: c.candidate, sdpMid: c.sdpMid, sdpMLineIndex: c.sdpMLineIndex } : {}
    };
    if (!broadcasterId) {
      localCandidateQueue.push(payload);
      log("Buffered local ICE candidate");
      return;
    }
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(payload));
      log("Sent local ICE candidate to " + broadcasterId);
    }
  };

  return pc;
}

function connectSignaling(){
  if (ws && ws.readyState === WebSocket.OPEN) return;
  log("Connecting to signaling: " + SIGNALING_URL);
  ws = new WebSocket(SIGNALING_URL);

  ws.onopen = () => log("Signaling connected");
  ws.onclose = () => log("Signaling closed");
  ws.onerror = (e) => log("Signaling error: " + e);

  ws.onmessage = async (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch (e) { log("Invalid JSON"); return; }
    log("Signaling msg: type=" + (msg.type||"") + " from=" + (msg.from||"?"));
    await handleSignalingMessage(msg);
  };
}

async function handleSignalingMessage(msg) {
  const { type, from, sdp, candidate } = msg;
  if (type === "offer") {
    broadcasterId = from;
    log("Received OFFER from " + broadcasterId);
    if (!pc) pc = createPeerConnection();
    try {
      await pc.setRemoteDescription({ type: "offer", sdp: sdp });
      log("Remote offer set");
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      const answerMsg = { type: "answer", from: VIEWER_ID, to: broadcasterId, sdp: pc.localDescription.sdp };
      ws.send(JSON.stringify(answerMsg));
      log("Sent ANSWER to " + broadcasterId);
      while (localCandidateQueue.length) {
        const cmsg = localCandidateQueue.shift();
        cmsg.to = broadcasterId;
        ws.send(JSON.stringify(cmsg));
        log("Flushed buffered ICE to " + broadcasterId);
      }
    } catch (e) {
      log("Error handling offer: " + e.message);
    }
  } else if (type === "ice") {
    try {
      if (!candidate || !candidate.candidate) {
        await pc.addIceCandidate(null);
        log("Remote ICE end (added null)");
        return;
      }
      await pc.addIceCandidate({ candidate: candidate.candidate, sdpMid: candidate.sdpMid, sdpMLineIndex: candidate.sdpMLineIndex });
      log("Added remote ICE candidate");
    } catch (e) {
      log("Failed to add remote ICE: " + e.message);
    }
  } else {
    log("Unknown signaling type: " + type);
  }
}

document.getElementById('btnReconnect').addEventListener('click', () => {
  if (pc) try { pc.close(); } catch(e) {}
  if (ws) try { ws.close(); } catch(e) {}
  document.getElementById('videos').innerHTML = "";
  broadcasterId = null;
  localCandidateQueue = [];
  pc = createPeerConnection();
  setTimeout(connectSignaling, 200);
});

document.getElementById('btnUnmute').addEventListener('click', () => {
  document.querySelectorAll('video').forEach(v => { v.muted = false; v.play().catch(()=>{}); });
  log("Unmuted all videos");
});

(function start(){
  pc = createPeerConnection();
  connectSignaling();
})();
</script>
</body>
</html>
