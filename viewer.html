<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Simple WebRTC Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; padding:18px; background:#f3f4f8; color:#222; }
    h2 { margin-top:0; }
    #videos { display:flex; gap:12px; flex-wrap:wrap; position:relative; }
    .tile { display:flex; flex-direction:column; gap:6px; align-items:flex-start; position:relative; }
    video { width:480px; height:270px; background:#000; border-radius:6px; display:block; }
    #log { margin-top:12px; background:#111; color:#ddd; padding:8px; border-radius:6px; max-height:220px; overflow:auto; font-family:monospace; font-size:12px; }
    button { margin-right:8px; padding:8px 10px; border-radius:6px; }
    #fallAlert { position:fixed; top:20px; right:20px; background:#8B0000; color:#fff; padding:20px 30px; border-radius:8px; font-size:18px; font-weight:bold; display:none; z-index:1000; box-shadow:0 4px 12px rgba(0,0,0,0.3); animation:pulse 0.6s infinite; }
    @keyframes pulse { 0%, 100% { opacity:1; } 50% { opacity:0.7; } }
  </style>
</head>
<body>
  <h2>Simple WebRTC Viewer</h2>
  <div>Status: <span id="status">idle</span></div>
  <div style="margin-top:10px;">
    <button id="btnReconnect">Reconnect</button>
    <button id="btnUnmute">Unmute All</button>
  </div>
  <div id="videos"></div>
  <div id="fallAlert">ðŸš¨ FALL DETECTED!</div>
  <pre id="log"></pre>

<script>
const SIGNALING_URL = "ws://44.221.81.71:8000/ws/viewer1";
const VIEWER_ID = "viewer1";

// ICE servers: STUN for NAT traversal, TURN for relay through firewall
const ICE_SERVERS = [
  { urls: "stun:stun.l.google.com:19302" },
  { urls: "stun:stun1.l.google.com:19302" },
  // AWS Coturn TURN server for cross-network relay
  { urls: "turn:52.64.197.245:3478?transport=udp", username: "webrtcuser", credential: "AlgoOrange@2025" },
  { urls: "turn:52.64.197.245:3478?transport=tcp", username: "webrtcuser", credential: "AlgoOrange@2025" }
];

let pc = null;
let ws = null;
let broadcasterId = null;
let localCandidateQueue = [];
let heartbeatInterval = null;
let fallAlertTimeout = null;
let reconnectAttempts = 0;
let maxReconnectAttempts = 5;
let reconnectDelay = 3000;
let videoTracks = {};
let lastPongTime = Date.now();

const logEl = document.getElementById('log');
const fallAlertEl = document.getElementById('fallAlert');

function log(msg) {
  const t = new Date().toLocaleTimeString();
  logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent;
  document.getElementById('status').textContent = msg.split('\n')[0];
  console.log(msg);
}

function showFallAlert() {
  fallAlertEl.style.display = 'block';
  log("ðŸš¨ FALL DETECTED - Alert displayed");
  
  if (fallAlertTimeout) clearTimeout(fallAlertTimeout);
  fallAlertTimeout = setTimeout(() => {
    fallAlertEl.style.display = 'none';
    log("Fall alert hidden");
  }, 5000);
}

function createPeerConnection(){
  if (pc && pc.connectionState !== "closed") {
    try { pc.close(); } catch(e) {}
  }
  pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

  pc.oniceconnectionstatechange = () => {
    const state = pc.iceConnectionState;
    if (state === "connected" || state === "completed") {
      log("âœ… ICE connection established");
    } else if (state === "checking") {
      log("ðŸ” ICE checking...");
    } else if (state === "failed") {
      log("âŒ ICE connection failed - verify TURN/STUN servers");
    }
  };
  
  pc.onconnectionstatechange = () => {
    const state = pc.connectionState;
    if (state === "connected") {
      log("âœ… WebRTC connection established - streaming video");
    } else if (state === "connecting") {
      log("ðŸ”— Connecting...");
    } else if (state === "failed") {
      log("âŒ Connection failed - attempting to reconnect...");
      // Trigger reconnection after a delay
      setTimeout(() => {
        if (pc && pc.connectionState === "failed") {
          log("ðŸ”„ Initiating reconnection...");
          document.getElementById('btnReconnect').click();
        }
      }, 2000);
    } else if (state === "disconnected") {
      log("âš ï¸ Connection disconnected - will attempt recovery");
      // Give it a moment to recover naturally
      setTimeout(() => {
        if (pc && pc.connectionState === "disconnected") {
          log("ðŸ”„ Reconnecting after disconnect...");
          document.getElementById('btnReconnect').click();
        }
      }, 3000);
    } else if (state === "closed") {
      log("Connection closed");
    }
  };
  
  pc.onsignalingstatechange = () => {
    const state = pc.signalingState;
    if (state === "stable") {
      log("âœ… Signaling stable");
    }
  };

  pc.ontrack = (event) => {
    // Use track.id as primary identifier (set by pusher), fallback to label, then generate one
    const trackId = event.track.id || event.track.label || ("track-" + (document.querySelectorAll('.tile').length+1));
    let tile = document.getElementById('tile-' + trackId);
    
    if (!tile) {
      // Create new tile for this track
      tile = document.createElement('div');
      tile.id = 'tile-' + trackId;
      tile.className = 'tile';
      const caption = document.createElement('div');
      caption.textContent = event.track.label || trackId;
      const video = document.createElement('video');
      video.id = 'vid-' + trackId;
      video.autoplay = true;
      video.playsInline = true;
      video.muted = true;
      video.controls = true;

      tile.appendChild(caption);
      tile.appendChild(video);
      document.getElementById('videos').appendChild(tile);

      // Store track reference
      videoTracks[trackId] = { video, stream: null };
      
      // Create MediaStream and set it
      const ms = new MediaStream();
      ms.addTrack(event.track);
      video.srcObject = ms;
      videoTracks[trackId].stream = ms;

      // Wait for metadata to load before playing
      const playVideo = () => {
        video.play().catch(e => log("video.play() rejected: " + e.message));
        video.removeEventListener('loadedmetadata', playVideo);
      };
      video.addEventListener('loadedmetadata', playVideo);
      
      log(`âœ… Created tile for track id=${trackId} label=${event.track.label || 'N/A'}`);
    } else {
      // Reuse existing video element - don't recreate MediaStream
      const video = tile.querySelector('video');
      if (videoTracks[trackId] && videoTracks[trackId].stream) {
        // Add track to existing stream
        const existingStream = videoTracks[trackId].stream;
        try {
          existingStream.addTrack(event.track);
          log(`ðŸ”„ Added track to existing stream for id=${trackId}`);
        } catch (e) {
          log(`âš ï¸ Could not add track: ${e.message}`);
        }
      }
    }
  };

  pc.onicecandidate = (ev) => {
    const c = ev.candidate;
    const payload = {
      type: "ice",
      from: VIEWER_ID,
      to: broadcasterId || null,
      candidate: c ? { candidate: c.candidate, sdpMid: c.sdpMid, sdpMLineIndex: c.sdpMLineIndex } : {}
    };
    if (!broadcasterId) {
      localCandidateQueue.push(payload);
      log("Buffered local ICE candidate");
      return;
    }
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(payload));
      log("Sent local ICE candidate to " + broadcasterId);
    }
  };

  return pc;
}

function connectSignaling(){
  if (ws && ws.readyState === WebSocket.OPEN) return;
  
  log("Connecting to signaling server...");
  ws = new WebSocket(SIGNALING_URL);

  ws.onopen = () => {
    log("âœ… Signaling connected");
    reconnectAttempts = 0;
    log("Waiting for offer from pusher...");
  };
  
  ws.onclose = () => {
    log("Signaling connection closed");
    // Attempt to reconnect
    if (reconnectAttempts < maxReconnectAttempts) {
      reconnectAttempts++;
      log(`ðŸ”„ Reconnecting... (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
      setTimeout(connectSignaling, reconnectDelay);
    } else {
      log("âŒ Max reconnection attempts reached");
    }
  };
  
  ws.onerror = (e) => {
    log("Signaling error: " + (e.message || "Connection failed"));
  };

  ws.onmessage = async (evt) => {
    try {
      const msg = JSON.parse(evt.data);
      if (msg.type === "ping") return;
      if (msg.type === "pong") {
        // Update last pong time for heartbeat monitoring
        lastPongTime = Date.now();
        return;
      }
      if (msg.type === "fall_alert") {
        log("ðŸš¨ FALL ALERT RECEIVED from " + (msg.from || "unknown"));
      }
      await handleSignalingMessage(msg);
    } catch (e) {
      log("Message parse error: " + e.message);
    }
  };
}

async function handleSignalingMessage(msg) {
  const { type, from, sdp, candidate, fall_detected } = msg;
  
  if (type === "fall_alert") {
    showFallAlert();
    return;
  }
  
  if (type === "offer") {
    broadcasterId = from;
    log("ðŸ“¨ Received OFFER from " + broadcasterId);
    
    if (!pc) pc = createPeerConnection();
    
    try {
      // Set remote description
      await pc.setRemoteDescription(new RTCSessionDescription({ type: "offer", sdp: sdp }));
      log("Remote SDP set");
      
      // Create and send answer
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      
      const answerMsg = { 
        type: "answer", 
        from: VIEWER_ID, 
        to: broadcasterId, 
        sdp: pc.localDescription.sdp 
      };
      ws.send(JSON.stringify(answerMsg));
      log("ðŸ“¤ Sent ANSWER");
      
      // Start heartbeat to maintain connection and detect stale connections
      if (heartbeatInterval) clearInterval(heartbeatInterval);
      lastPongTime = Date.now();
      heartbeatInterval = setInterval(() => {
        if (ws && ws.readyState === WebSocket.OPEN && broadcasterId) {
          // Check if we haven't received pong in 30 seconds
          if (Date.now() - lastPongTime > 30000) {
            log("âš ï¸ No pong received - connection may be stale");
            document.getElementById('btnReconnect').click();
            return;
          }
          ws.send(JSON.stringify({ type: "ping", from: VIEWER_ID, to: broadcasterId }));
        }
      }, 10000); // Heartbeat every 10 seconds
      
      // Flush any buffered ICE candidates
      while (localCandidateQueue.length > 0) {
        const cmsg = localCandidateQueue.shift();
        cmsg.to = broadcasterId;
        ws.send(JSON.stringify(cmsg));
      }
      log("ICE candidates flushed");
      
    } catch (e) {
      log("âŒ Error processing offer: " + e.message);
    }
    
  } else if (type === "ice") {
    if (!pc) return;
    
    try {
      const candidateData = candidate || {};
      
      // Handle ICE end
      if (!candidateData.candidate) {
        await pc.addIceCandidate(null);
        log("ICE gathering complete");
        return;
      }
      
      // Add ICE candidate
      const iceCandidate = new RTCIceCandidate({
        candidate: candidateData.candidate,
        sdpMid: candidateData.sdpMid,
        sdpMLineIndex: candidateData.sdpMLineIndex
      });
      
      await pc.addIceCandidate(iceCandidate);
      
    } catch (e) {
      // Silently ignore ICE errors - they're often harmless
      if (!e.message.includes("duplicate")) {
        // Only log non-duplicate errors
      }
    }
  } else if (type === "ice-complete") {
    if (!pc) return;
    try {
      await pc.addIceCandidate(null);
      log("âœ… Remote ICE gathering complete");
    } catch (e) {
      // Silently ignore
    }
  }
}

document.getElementById('btnReconnect').addEventListener('click', () => {
  log("ðŸ”„ Manual reconnect triggered");
  if (heartbeatInterval) clearInterval(heartbeatInterval);
  if (pc) try { pc.close(); } catch(e) {}
  if (ws) try { ws.close(); } catch(e) {}
  
  document.getElementById('videos').innerHTML = "";
  broadcasterId = null;
  localCandidateQueue = [];
  
  // Restart connection
  pc = createPeerConnection();
  setTimeout(() => connectSignaling(), 500);
});

document.getElementById('btnUnmute').addEventListener('click', () => {
  document.querySelectorAll('video').forEach(v => { 
    v.muted = false; 
    v.play().catch(() => {});
  });
  log("ðŸ”Š Unmuted all videos");
});

// Initialize connection on page load
(function initialize(){
  log("Initializing WebRTC viewer...");
  pc = createPeerConnection();
  connectSignaling();
})();
</script>
</body>
</html>
