<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebRTC Viewer (with TURN debug)</title>
  <style>
    body{font-family:Arial;margin:8px}
    #status{font-weight:bold}
    #log{white-space:pre-wrap;background:#f7f7f7;border:1px solid #ddd;padding:8px;height:220px;overflow:auto}
    video{width:100%;max-height:60vh;background:#000;margin-top:8px}
  </style>
</head>
<body>
  <h3>Viewer</h3>
  <div id="status">Status: starting...</div>
  <div id="log"></div>
  <video id="remoteVideo" autoplay playsinline muted controls></video>

<script>
  const LOG = document.getElementById('log');
  function log(...a){ console.log(...a); LOG.textContent += a.join(' ') + '\n'; LOG.scrollTop = LOG.scrollHeight; }
  function setStatus(s){ document.getElementById('status').textContent = 'Status: ' + s; log('STATUS:', s); }

  // ---------- CONFIG ----------
  const SIGNALING_WSS = "wss://camera-relay.onrender.com/ws/viewer1";
  const CAMERA_ID = "camera1";

  // TURN details
  // Use all possible forms your provider supports -- test each.
  const TURN_USER = "000000002078730066";
  const TURN_PASS = "dEwJy42Qu8kox+L9Bp1tgkBa0iw=";
  const TURN_HOST = "relay1.expressturn.com";

  const ICE_SERVERS = [
    { urls: "stun:stun.l.google.com:19302" },
    // UDP
    { urls: `turn:${TURN_HOST}:3480?transport=udp`, username: TURN_USER, credential: TURN_PASS },
    // TCP
    { urls: `turn:${TURN_HOST}:3480?transport=tcp`, username: TURN_USER, credential: TURN_PASS },
    // Common alternative ports (try these if above fails)
    { urls: `turn:${TURN_HOST}:3478?transport=tcp`, username: TURN_USER, credential: TURN_PASS },
    // If provider supports TLS/secure TURN (turns:) on 5349 or 443
    { urls: `turns:${TURN_HOST}:5349`, username: TURN_USER, credential: TURN_PASS },
    { urls: `turns:${TURN_HOST}:443`, username: TURN_USER, credential: TURN_PASS }
  ];
  // ----------------------------

  setStatus('creating RTCPeerConnection');
  const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
  const remoteVideo = document.getElementById('remoteVideo');
  remoteVideo.muted = true; remoteVideo.playsInline = true;

  pc.onicecandidate = (e) => {
    if (!e.candidate) { log('ICE: gathering finished'); return; }
    log('Local candidate:', e.candidate.candidate);
    // You don't need to send local candidates here (signaling will handle in ontrack flow)
    // but we'll send them to server so pusher can add them (we already do in our code)
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'ice', from: 'viewer1', to: CAMERA_ID, candidate: {
        candidate: e.candidate.candidate, sdpMid: e.candidate.sdpMid, sdpMLineIndex: e.candidate.sdpMLineIndex
      }}));
      log('Sent local ICE candidate to signaling');
    }
  };

  pc.onicegatheringstatechange = () => log('ICE gathering state:', pc.iceGatheringState);
  pc.oniceconnectionstatechange = () => log('ICE connection state:', pc.iceConnectionState);
  pc.onconnectionstatechange = () => log('Connection state:', pc.connectionState);

  pc.ontrack = (evt) => {
    log('ontrack', evt);
    const [stream] = evt.streams;
    if (stream) remoteVideo.srcObject = stream;
    else {
      const ms = remoteVideo.srcObject instanceof MediaStream ? remoteVideo.srcObject : new MediaStream();
      ms.addTrack(evt.track);
      remoteVideo.srcObject = ms;
    }
    remoteVideo.play().then(()=>log('play ok')).catch(e=>log('play error', e));
  };

  // Signaling WS
  let ws;
  try {
    ws = new WebSocket(SIGNALING_WSS);
  } catch (e){ log('WS construct error', e); setStatus('ws construct error'); throw e; }

  ws.onopen = () => { log('WS open', SIGNALING_WSS); setStatus('WS open, waiting for offer'); };
  ws.onclose = () => { log('WS closed'); setStatus('WS closed'); };
  ws.onerror = (e) => { log('WS error', e); setStatus('WS error'); };

  ws.onmessage = async (evt) => {
    log('WS message (truncated):', (evt.data||'').slice(0,200));
    const obj = JSON.parse(evt.data);
    if (obj.type === 'offer'){
      setStatus('Got offer; setting remote description');
      await pc.setRemoteDescription({ type: 'offer', sdp: obj.sdp });
      setStatus('Creating answer');
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(JSON.stringify({ type: 'answer', from: 'viewer1', to: obj.from, sdp: pc.localDescription.sdp }));
      setStatus('Answer sent; waiting ICE');
      log('Answer sent');
    } else if (obj.type === 'ice'){
      try {
        await pc.addIceCandidate({ candidate: obj.candidate.candidate, sdpMid: obj.candidate.sdpMid, sdpMLineIndex: obj.candidate.sdpMLineIndex });
        log('Added remote ICE candidate');
      } catch(e){ log('addIceCandidate err', e); }
    }
  };
</script>
</body>
</html>
