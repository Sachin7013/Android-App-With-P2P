<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Simple WebRTC Viewer</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background:#f5f6fb; }
    #videos { display:flex; gap:12px; flex-wrap:wrap; }
    video { width: 480px; height: 270px; background:#000; border-radius:6px; }
    #status { margin: 8px 0; color:#333; }
    button { padding:8px 12px; border-radius:6px; }
    pre { background:#222;color:#fff;padding:8px;border-radius:6px; max-height:160px; overflow:auto; }
  </style>
</head>
<body>
  <h2>Simple WebRTC Viewer</h2>
  <div id="status">Status: <span id="statText">idle</span></div>
  <div id="videos"></div>
  <div style="margin-top:12px;">
    <button id="btnReconnect">Reconnect</button>
    <button id="btnUnmuteAll">Unmute All</button>
  </div>
  <h4>Logs</h4>
  <pre id="log"></pre>

<script>
/* ---------- CONFIG ---------- */
/* change this to your actual signaling endpoint for this viewer */
const SIGNALING_URL = "wss://camera-relay.onrender.com/ws/viewer1"; // <- update if needed
const VIEWER_ID = "viewer1";

/* optional TURN / STUN - add if you have */
const ICE_SERVERS = [
  { urls: "stun:stun.l.google.com:19302" },
  // example TURN (uncomment & fill if you have): 
  // { urls: "turn:52.64.197.245:3478?transport=udp", username: "turnuser", credential: "turnpass" }
];

/* ---------- STATE ---------- */
let pc = null;
let ws = null;
let logs = [];
let trackCount = 0;
let broadcasterId = null;

/* ---------- UI helpers ---------- */
const logEl = document.getElementById('log');
function log(msg) {
  const t = new Date().toLocaleTimeString();
  logs.push(`[${t}] ${msg}`);
  if (logs.length > 1000) logs.shift();
  logEl.textContent = logs.join("\n");
  console.log(msg);
  document.getElementById('statText').textContent = msg.split('\n')[0];
}

/* ---------- WebRTC setup ---------- */
function createPeerConnection() {
  pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

  pc.oniceconnectionstatechange = () => {
    log("ICE: " + pc.iceConnectionState);
  };
  pc.onconnectionstatechange = () => {
    log("Connection: " + pc.connectionState);
  };

  pc.ontrack = (event) => {
    // create an element per incoming track
    trackCount += 1;
    const id = "track-" + trackCount;
    const video = document.createElement('video');
    video.id = id;
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true; // start muted to allow autoplay
    video.controls = true;

    // prefer streams if provided
    if (event.streams && event.streams[0]) {
      video.srcObject = event.streams[0];
    } else {
      const ms = new MediaStream();
      ms.addTrack(event.track);
      video.srcObject = ms;
    }

    const label = event.track.label || `Camera ${trackCount}`;
    const caption = document.createElement('div');
    caption.textContent = label;
    caption.style.fontSize = '12px';
    caption.style.marginBottom = '6px';

    const container = document.createElement('div');
    container.appendChild(caption);
    container.appendChild(video);

    document.getElementById('videos').appendChild(container);

    // try to play (handle autoplay policies)
    video.play().catch(e => {
      log("video.play() rejected: " + e.message);
    });

    log("Received track: " + label + " (kind=" + event.track.kind + ")");
  };

  pc.onicecandidate = (ev) => {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    // send candidate to the broadcaster (must be set from OFFER)
    if (!broadcasterId) {
      // if no broadcaster yet, queueing could be implemented; here we just log
      log("onicecandidate: broadcasterId unknown yet, skipping candidate");
      return;
    }

    const cand = ev.candidate;
    const msg = {
      type: "ice",
      from: VIEWER_ID,
      to: broadcasterId,
      candidate: cand ? {
        candidate: cand.candidate,
        sdpMid: cand.sdpMid,
        sdpMLineIndex: cand.sdpMLineIndex
      } : { } // empty candidate means end-of-candidates
    };
    ws.send(JSON.stringify(msg));
    log("Sent local ICE candidate to " + broadcasterId);
  };

  return pc;
}

/* ---------- Signaling ---------- */
function connectSignaling() {
  if (ws && ws.readyState === WebSocket.OPEN) return;
  log("Connecting to signaling: " + SIGNALING_URL);
  ws = new WebSocket(SIGNALING_URL);

  ws.onopen = () => {
    log("Signaling connected");
  };

  ws.onmessage = async (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch (e) { log("Invalid JSON from signaling"); return; }
    log("Signaling message: " + (msg.type||"unknown") + " from:" + (msg.from||"?"));
    await handleSignalingMessage(msg);
  };

  ws.onerror = (e) => {
    log("WebSocket error");
  };

  ws.onclose = () => {
    log("Signaling closed");
  };
}

async function handleSignalingMessage(msg) {
  const { type, from, sdp, candidate } = msg;

  if (type === "offer") {
    // OFFER from pusher (camera)
    broadcasterId = from;
    log("Got OFFER from " + broadcasterId + " â€” creating answer");

    if (!pc || pc.connectionState === "closed") {
      createPeerConnection();
    }

    try {
      const offer = { type: "offer", sdp: sdp };
      await pc.setRemoteDescription(offer);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // send answer back to broadcaster
      const answerMsg = {
        type: "answer",
        from: VIEWER_ID,
        to: broadcasterId,
        sdp: pc.localDescription.sdp
      };
      ws.send(JSON.stringify(answerMsg));
      log("Sent ANSWER to " + broadcasterId);
    } catch (e) {
      log("Failed to handle offer: " + e.message);
    }

  } else if (type === "ice") {
    // incoming ICE candidate from broadcaster
    try {
      if (!candidate || !candidate.candidate) {
        // end-of-candidates
        await pc.addIceCandidate(null);
        log("Remote ICE gathering complete");
        return;
      }
      const ice = {
        candidate: candidate.candidate,
        sdpMid: candidate.sdpMid,
        sdpMLineIndex: candidate.sdpMLineIndex
      };
      await pc.addIceCandidate(ice);
      log("Added remote ICE candidate");
    } catch (e) {
      log("Error adding remote ICE: " + e.message);
    }
  } else {
    log("Unknown signaling type: " + type);
  }
}

/* ---------- Controls ---------- */
document.getElementById('btnReconnect').addEventListener('click', () => {
  if (pc) pc.close();
  if (ws) ws.close();
  document.getElementById('videos').innerHTML = "";
  trackCount = 0; broadcasterId = null;
  pc = createPeerConnection();
  setTimeout(connectSignaling, 200);
});

document.getElementById('btnUnmuteAll').addEventListener('click', () => {
  document.querySelectorAll('video').forEach(v => { v.muted = false; v.play().catch(()=>{}); });
  log("Unmuted all videos (user action)");
});

/* ---------- startup ---------- */
(async function start(){
  pc = createPeerConnection();
  connectSignaling();
})();
</script>
</body>
</html>
