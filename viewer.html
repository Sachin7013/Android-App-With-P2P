<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Simple WebRTC Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, Helvetica, sans-serif; padding:18px; background:#f3f4f8; color:#222; }
    h2 { margin-top:0; }
    #videos { display:flex; gap:12px; flex-wrap:wrap; }
    video { width:480px; height:270px; background:#000; border-radius:6px; display:block; }
    #log { margin-top:12px; background:#111; color:#ddd; padding:8px; border-radius:6px; max-height:220px; overflow:auto; font-family:monospace; font-size:12px; }
    button { margin-right:8px; padding:8px 10px; border-radius:6px; }
  </style>
</head>
<body>
  <h2>Simple WebRTC Viewer</h2>
  <div>Status: <span id="status">idle</span></div>
  <div style="margin-top:10px;">
    <button id="btnReconnect">Reconnect</button>
    <button id="btnUnmute">Unmute All</button>
  </div>
  <div id="videos"></div>
  <pre id="log"></pre>

<script>
/* ---------- CONFIG - update if necessary ---------- */
const SIGNALING_URL = "wss://camera-relay.onrender.com/ws/viewer1"; // update to your server/path if needed
const VIEWER_ID = "viewer1";

/* Add TURN / STUN servers here if you need them */
const ICE_SERVERS = [
  { urls: "stun:stun.l.google.com:19302" }
  // Example TURN: { urls: "turn:52.64.197.245:3478?transport=udp", username: "turnuser", credential: "turnpass" }
];

/* ---------- STATE ---------- */
let pc = null;
let ws = null;
let broadcasterId = null;
let localCandidateQueue = []; // buffer local ice candidates until we know broadcasterId

/* ---------- UI helpers ---------- */
const logEl = document.getElementById('log');
function log(msg) {
  const t = new Date().toLocaleTimeString();
  logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent;
  document.getElementById('status').textContent = msg.split('\n')[0];
  console.log(msg);
}

/* ---------- create peer connection ---------- */
function createPeerConnection() {
  if (pc && pc.connectionState !== "closed") {
    try { pc.close(); } catch(e) {}
  }

  pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

  pc.oniceconnectionstatechange = () => log("ICE state: " + pc.iceConnectionState);
  pc.onconnectionstatechange = () => log("Connection state: " + pc.connectionState);
  pc.onsignalingstatechange = () => log("Signaling state: " + pc.signalingState);

  // ontrack: always create a new video element per incoming track
  pc.ontrack = (event) => {
    const trackIndex = document.querySelectorAll('video').length + 1;
    const label = event.track.label || `Camera ${trackIndex}`;

    const caption = document.createElement('div');
    caption.textContent = label;
    caption.style.fontSize = '13px';
    caption.style.marginBottom = '6px';

    const video = document.createElement('video');
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true; // start muted to avoid autoplay block
    video.controls = true;

    // prefer `streams` if present
    if (event.streams && event.streams[0]) {
      video.srcObject = event.streams[0];
    } else {
      const ms = new MediaStream();
      ms.addTrack(event.track);
      video.srcObject = ms;
    }

    const container = document.createElement('div');
    container.appendChild(caption);
    container.appendChild(video);
    document.getElementById('videos').appendChild(container);

    // try to play (catch autoplay rejection)
    video.play().catch(e => log("video.play() rejected: " + e.message));

    log(`Received track: id=${event.track.id} label=${event.track.label || "N/A"} kind=${event.track.kind}`);
  };

  // buffer local ICE candidates if we don't yet know broadcaster id
  pc.onicecandidate = (ev) => {
    const c = ev.candidate;
    const payload = {
      type: "ice",
      from: VIEWER_ID,
      to: broadcasterId || null,
      candidate: c ? {
        candidate: c.candidate,
        sdpMid: c.sdpMid,
        sdpMLineIndex: c.sdpMLineIndex
      } : {}
    };

    if (!broadcasterId) {
      // buffer until we know who to send to
      localCandidateQueue.push(payload);
      log("Buffered local ICE candidate (broadcaster unknown)");
      return;
    }

    // send immediately
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify(payload));
      log("Sent local ICE candidate to " + broadcasterId);
    } else {
      log("Signaling WS not open; buffered local ICE candidate");
      localCandidateQueue.push(payload);
    }
  };

  return pc;
}

/* ---------- signaling ---------- */
function connectSignaling() {
  if (ws && ws.readyState === WebSocket.OPEN) return;
  log("Connecting to signaling: " + SIGNALING_URL);
  ws = new WebSocket(SIGNALING_URL);

  ws.onopen = () => log("Signaling connected");
  ws.onclose = () => log("Signaling closed");
  ws.onerror = (e) => log("Signaling error");

  ws.onmessage = async (evt) => {
    let msg;
    try { msg = JSON.parse(evt.data); } catch (e) { log("Invalid JSON from signaling"); return; }
    log("Signaling msg: type=" + (msg.type||"") + " from=" + (msg.from||"?"));
    await handleSignalingMessage(msg);
  };
}

async function handleSignalingMessage(msg) {
  const { type, from, sdp, candidate } = msg;

  if (type === "offer") {
    // OFFER from broadcaster (camera)
    broadcasterId = from;
    log("Received OFFER from " + broadcasterId);

    // flush any buffered local candidates to new broadcaster later (after answer)
    if (!pc) pc = createPeerConnection();

    // apply remote offer
    try {
      await pc.setRemoteDescription({ type: "offer", sdp: sdp });
      log("Remote description (offer) set");

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      const answerMsg = {
        type: "answer",
        from: VIEWER_ID,
        to: broadcasterId,
        sdp: pc.localDescription.sdp
      };
      ws.send(JSON.stringify(answerMsg));
      log("Sent ANSWER to " + broadcasterId);

      // send any buffered local candidates now that we know broadcasterId
      while (localCandidateQueue.length > 0) {
        const cmsg = localCandidateQueue.shift();
        cmsg.to = broadcasterId;
        ws.send(JSON.stringify(cmsg));
        log("Flushed buffered local ICE candidate to " + broadcasterId);
      }
    } catch (e) {
      log("Error handling offer: " + e.message);
    }

  } else if (type === "ice") {
    try {
      if (!candidate || !candidate.candidate) {
        // end-of-candidates signal
        await pc.addIceCandidate(null);
        log("Remote ICE end-of-candidates (added null)");
        return;
      }
      // add remote candidate
      await pc.addIceCandidate({
        candidate: candidate.candidate,
        sdpMid: candidate.sdpMid,
        sdpMLineIndex: candidate.sdpMLineIndex
      });
      log("Added remote ICE candidate");
    } catch (e) {
      log("Failed to add remote ICE candidate: " + e.message);
    }
  } else {
    log("Unknown signaling message type: " + type);
  }
}

/* ---------- controls ---------- */
document.getElementById('btnReconnect').addEventListener('click', () => {
  if (pc) try { pc.close(); } catch(e) {}
  if (ws) try { ws.close(); } catch(e) {}
  document.getElementById('videos').innerHTML = "";
  broadcasterId = null;
  localCandidateQueue = [];
  pc = createPeerConnection();
  setTimeout(connectSignaling, 200);
});

document.getElementById('btnUnmute').addEventListener('click', () => {
  document.querySelectorAll('video').forEach(v => { v.muted = false; v.play().catch(()=>{}); });
  log("Unmuted all videos (user action)");
});

/* ---------- startup ---------- */
(function start() {
  pc = createPeerConnection();
  connectSignaling();
})();
</script>
</body>
</html>
