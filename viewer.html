<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé• Multi-Camera WebRTC Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Segoe UI", -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* ========== HEADER ========== */
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        /* ========== STATUS BAR ========== */
        .status-bar {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .status-indicator {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ff6b6b;
            animation: pulse 2s infinite;
            flex-shrink: 0;
        }

        .status-indicator.connected {
            background: #51cf66;
            animation: pulse-green 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes pulse-green {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        .status-label {
            font-weight: 600;
            color: #667eea;
            font-size: 0.95em;
        }

        .status-value {
            color: #666;
            font-size: 0.9em;
        }

        /* ========== ALERTS ========== */
        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 12px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .alert.show {
            display: flex;
        }

        .alert-error {
            background: #ffe0e0;
            color: #d32f2f;
            border-left: 4px solid #d32f2f;
        }

        .alert-success {
            background: #e8f5e9;
            color: #388e3c;
            border-left: 4px solid #388e3c;
        }

        /* ========== VIDEO GRID ========== */
        .videos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .video-container {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
        }

        .video-container:hover {
            transform: translateY(-8px);
            box-shadow: 0 16px 50px rgba(0, 0, 0, 0.4);
        }

        .video-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 75%;
            overflow: hidden;
            background: #000;
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .video-label {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        .video-stats {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.85);
            color: #51cf66;
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 10;
            font-weight: 600;
            backdrop-filter: blur(5px);
        }

        /* ========== CONTROLS ========== */
        .controls {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .controls h3 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.1em;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        button {
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ========== STATS PANEL ========== */
        .stats-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .stats-panel h3 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.1em;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            color: #667eea;
            font-family: 'Courier New', monospace;
            font-weight: 700;
        }

        /* ========== RESPONSIVE ========== */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }

            .videos-grid {
                grid-template-columns: 1fr;
            }

            .control-buttons {
                grid-template-columns: 1fr;
            }

            .status-bar {
                grid-template-columns: 1fr;
            }
        }

        /* ========== LOADING STATE ========== */
        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üé• Multi-Camera WebRTC Viewer</h1>
            <p>Live streaming via TURN server</p>
        </div>

        <!-- Alerts -->
        <div id="errorAlert" class="alert alert-error">
            <span>‚ö†Ô∏è</span>
            <span id="errorMsg"></span>
        </div>
        <div id="successAlert" class="alert alert-success">
            <span>‚úÖ</span>
            <span id="successMsg"></span>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator" id="statusIndicator"></div>
                <div>
                    <div class="status-label">Connection Status</div>
                    <div class="status-value" id="statusText">Initializing...</div>
                </div>
            </div>
            <div class="status-item">
                <div class="status-label">üì° Signaling</div>
                <div class="status-value" id="signalingStatus">Disconnected</div>
            </div>
            <div class="status-item">
                <div class="status-label">üîó Peer Connection</div>
                <div class="status-value" id="peerStatus">new</div>
            </div>
            <div class="status-item">
                <div class="status-label">üìπ Video Tracks</div>
                <div class="status-value" id="trackCount">0</div>
            </div>
        </div>

        <!-- Video Grid -->
        <div class="videos-grid" id="videosGrid">
            <!-- Videos will be added dynamically -->
        </div>

        <!-- Controls -->
        <div class="controls">
            <h3>‚öôÔ∏è Controls</h3>
            <div class="control-buttons">
                <button onclick="toggleAllMute()">üîä Mute/Unmute All</button>
                <button onclick="toggleFullscreen()">‚õ∂ Fullscreen</button>
                <button onclick="resetConnection()">üîÑ Reset Connection</button>
                <button onclick="copyLogs()">üìã Copy Logs</button>
            </div>
        </div>

        <!-- Statistics -->
        <div class="stats-panel">
            <h3>üìä Connection Statistics</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">ICE State</div>
                    <div class="stat-value" id="iceState">new</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Connection State</div>
                    <div class="stat-value" id="connState">new</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Signaling State</div>
                    <div class="stat-value" id="sigState">stable</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Data Received</div>
                    <div class="stat-value" id="bytesReceived">0 MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Packets Lost</div>
                    <div class="stat-value" id="packetsLost">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Jitter</div>
                    <div class="stat-value" id="jitter">0 ms</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // CONFIGURATION
        // ========================================
        
        const CONFIG = {
            // CHANGE THIS TO YOUR SIGNALING SERVER IP
            signalingUrl: "ws://localhost:8000/ws/viewer1",
            
            stunServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" },
            ],
            
            // ADD YOUR TURN SERVER HERE
            turnServers: [
                // {
                //     urls: "turn:YOUR-TURN-IP:3478?transport=udp",
                //     username: "turnuser",
                //     credential: "turnpassword",
                // },
                // {
                //     urls: "turn:YOUR-TURN-IP:3478?transport=tcp",
                //     username: "turnuser",
                //     credential: "turnpassword",
                // },
            ],
        };

        // ========================================
        // STATE & VARIABLES
        // ========================================
        
        let pc = null;
        let ws = null;
        let videoElements = {};
        let statsInterval = null;
        let logs = [];

        // ========================================
        // LOGGING
        // ========================================
        
        function log(msg, type = "info") {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] [${type.toUpperCase()}] ${msg}`;
            console.log(logEntry);
            logs.push(logEntry);
            
            // Keep last 1000 logs only
            if (logs.length > 1000) {
                logs.shift();
            }
        }

        function showError(msg) {
            const alert = document.getElementById("errorAlert");
            document.getElementById("errorMsg").textContent = msg;
            alert.classList.add("show");
            log(msg, "error");
            setTimeout(() => alert.classList.remove("show"), 5000);
        }

        function showSuccess(msg) {
            const alert = document.getElementById("successAlert");
            document.getElementById("successMsg").textContent = msg;
            alert.classList.add("show");
            log(msg, "success");
            setTimeout(() => alert.classList.remove("show"), 3000);
        }

        function copyLogs() {
            const logsText = logs.join("\n");
            navigator.clipboard.writeText(logsText).then(() => {
                showSuccess("üìã Logs copied to clipboard!");
            });
        }

        // ========================================
        // STATUS UPDATES
        // ========================================
        
        function updateStatus(text, isConnected = false) {
            document.getElementById("statusText").textContent = text;
            const indicator = document.getElementById("statusIndicator");
            if (isConnected) {
                indicator.classList.add("connected");
            } else {
                indicator.classList.remove("connected");
            }
        }

        // ========================================
        // VIDEO ELEMENT MANAGEMENT
        // ========================================
        
        function createVideoElement(trackLabel) {
            const videosGrid = document.getElementById("videosGrid");
            
            const container = document.createElement("div");
            container.className = "video-container";
            container.id = `video-container-${trackLabel}`;

            const wrapper = document.createElement("div");
            wrapper.className = "video-wrapper";

            const video = document.createElement("video");
            video.id = `video-${trackLabel}`;
            video.autoplay = true;
            video.playsinline = true;
            video.muted = false;

            const label = document.createElement("div");
            label.className = "video-label";
            label.textContent = `üìπ ${trackLabel}`;

            const stats = document.createElement("div");
            stats.className = "video-stats";
            stats.id = `stats-${trackLabel}`;
            stats.textContent = "0 fps";

            wrapper.appendChild(video);
            wrapper.appendChild(label);
            wrapper.appendChild(stats);
            container.appendChild(wrapper);
            videosGrid.appendChild(container);

            videoElements[trackLabel] = video;
            log(`üìπ Created video element for ${trackLabel}`);
        }

        // ========================================
        // WEBRTC INITIALIZATION
        // ========================================
        
        async function initializeWebRTC() {
            log("üîß Initializing WebRTC...");
            
            try {
                const iceServers = [
                    ...CONFIG.stunServers,
                    ...CONFIG.turnServers,
                ];

                pc = new RTCPeerConnection({ iceServers });
                log("‚úÖ Peer connection created");

                // ICE Connection State
                pc.oniceconnectionstatechange = () => {
                    const state = pc.iceConnectionState;
                    document.getElementById("iceState").textContent = state;
                    log(`üßä ICE state: ${state}`);

                    if (state === "connected" || state === "completed") {
                        updateStatus("üü¢ Connected to broadcaster", true);
                    } else if (state === "failed") {
                        showError("‚ùå ICE connection failed!");
                        updateStatus("üî¥ Connection Failed", false);
                    }
                };

                // Peer Connection State
                pc.onconnectionstatechange = () => {
                    const state = pc.connectionState;
                    document.getElementById("connState").textContent = state;
                    document.getElementById("peerStatus").textContent = state;
                    log(`üîó Connection state: ${state}`);

                    if (state === "connected") {
                        showSuccess("‚úÖ Connected to broadcaster!");
                    } else if (state === "failed") {
                        showError("‚ùå Connection failed - try resetting");
                    }
                };

                // Signaling State
                pc.onsignalingstatechange = () => {
                    document.getElementById("sigState").textContent = pc.signalingState;
                };

                // Track Received
                pc.ontrack = (event) => {
                    log(`üì° Track received: ${event.track.kind} - ${event.track.label}`);
                    
                    const trackLabel = event.track.label || `Track-${Object.keys(videoElements).length + 1}`;
                    
                    if (!videoElements[trackLabel]) {
                        createVideoElement(trackLabel);
                    }

                    const videoElement = videoElements[trackLabel];
                    const stream = new MediaStream([event.track]);
                    videoElement.srcObject = stream;

                    document.getElementById("trackCount").textContent = Object.keys(videoElements).length;
                    log(`‚úÖ Video playing: ${trackLabel}`);
                };

                // ICE Candidate
                pc.onicecandidate = (event) => {
                    if (event.candidate) {
                        sendMessage({
                            type: "ice",
                            from: "viewer1",
                            to: "broadcaster1",
                            candidate: {
                                candidate: event.candidate.candidate,
                                sdpMid: event.candidate.sdpMid,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                            },
                        });
                    }
                };

                return true;
            } catch (e) {
                showError(`‚ùå WebRTC init failed: ${e.message}`);
                return false;
            }
        }

        // ========================================
        // SIGNALING
        // ========================================
        
        async function connectSignaling() {
            log(`üì° Connecting to: ${CONFIG.signalingUrl}`);
            updateStatus("üîÑ Connecting to signaling server...", false);

            try {
                ws = new WebSocket(CONFIG.signalingUrl);

                ws.onopen = () => {
                    log("‚úÖ Connected to signaling server");
                    document.getElementById("signalingStatus").textContent = "Connected";
                    updateStatus("üì° Waiting for offer from broadcaster...", false);
                };

                ws.onmessage = async (event) => {
                    try {
                        const msg = JSON.parse(event.data);
                        await handleSignalingMessage(msg);
                    } catch (e) {
                        log(`‚ö†Ô∏è  Message parsing error: ${e.message}`, "warn");
                    }
                };

                ws.onerror = (error) => {
                    showError(`‚ùå WebSocket error`);
                    log(`‚ùå WebSocket error: ${error}`, "error");
                    document.getElementById("signalingStatus").textContent = "Error";
                };

                ws.onclose = () => {
                    log("‚ö†Ô∏è  Signaling server disconnected");
                    updateStatus("‚ùå Disconnected from signaling", false);
                    document.getElementById("signalingStatus").textContent = "Disconnected";
                };
            } catch (e) {
                showError(`‚ùå Failed to connect: ${e.message}`);
            }
        }

        function sendMessage(msg) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(msg));
            }
        }

        async function handleSignalingMessage(msg) {
            const { type, from, sdp, candidate } = msg;

            if (type === "offer") {
                log(`üì® Received OFFER from ${from}`);
                log(`   üìπ Tracks: ${msg.num_tracks || "?"}, Cameras: ${(msg.cameras || []).join(", ")}`);

                try {
                    const offer = new RTCSessionDescription({
                        type: "offer",
                        sdp: sdp,
                    });

                    await pc.setRemoteDescription(offer);
                    log("‚úÖ Remote description set");

                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);

                    sendMessage({
                        type: "answer",
                        from: "viewer1",
                        to: from,
                        sdp: pc.localDescription.sdp,
                    });

                    log("‚úÖ Sent ANSWER - stream starting...");
                    updateStatus("üü° Connecting...", false);
                } catch (e) {
                    showError(`‚ùå Offer handling failed: ${e.message}`);
                }
            } 
            else if (type === "ice") {
                try {
                    if (!candidate.candidate) {
                        await pc.addIceCandidate(null);
                        log("‚úÖ Remote ICE gathering complete");
                        return;
                    }

                    const iceCandidate = new RTCIceCandidate({
                        candidate: candidate.candidate,
                        sdpMid: candidate.sdpMid,
                        sdpMLineIndex: candidate.sdpMLineIndex,
                    });

                    await pc.addIceCandidate(iceCandidate);
                } catch (e) {
                    log(`‚ö†Ô∏è  ICE error: ${e.message}`, "warn");
                }
            }
        }

        // ========================================
        // STATISTICS
        // ========================================
        
        async function updateStats() {
            if (!pc) return;

            try {
                const stats = await pc.getStats();
                let bytesReceived = 0;
                let packetsLost = 0;
                let jitter = 0;

                stats.forEach((report) => {
                    if (report.type === "inbound-rtp" && report.mediaType === "video") {
                        bytesReceived += report.bytesReceived || 0;
                        packetsLost += report.packetsLost || 0;
                        jitter = Math.round((report.jitter || 0) * 1000);
                    }
                });

                document.getElementById("bytesReceived").textContent =
                    (bytesReceived / (1024 * 1024)).toFixed(2) + " MB";
                document.getElementById("packetsLost").textContent = packetsLost;
                document.getElementById("jitter").textContent = jitter + " ms";
            } catch (e) {
                // Silent fail for stats
            }
        }

        // ========================================
        // CONTROLS
        // ========================================
        
        function toggleAllMute() {
            const isMuted = Object.values(videoElements)[0]?.muted;
            Object.values(videoElements).forEach((video) => {
                video.muted = !isMuted;
            });
            log(`üîä All videos ${!isMuted ? "muted" : "unmuted"}`);
        }

        function toggleFullscreen() {
            const container = document.querySelector(".container");
            if (!document.fullscreenElement) {
                container.requestFullscreen().catch(e => {
                    log(`‚ö†Ô∏è  Fullscreen error: ${e.message}`, "warn");
                });
            } else {
                document.exitFullscreen();
            }
        }

        function resetConnection() {
            log("üîÑ Resetting connection...");
            if (pc) pc.close();
            if (ws) ws.close();
            videoElements = {};
            document.getElementById("videosGrid").innerHTML = "";
            setTimeout(init, 1000);
        }

        // ========================================
        // INITIALIZATION
        // ========================================
        
        async function init() {
            log("=" * 70);
            log("üé• VIEWER INITIALIZATION STARTED");
            log("=" * 70);
            
            updateStatus("üîß Initializing...", false);

            const webrtcOk = await initializeWebRTC();
            if (!webrtcOk) return;

            await connectSignaling();

            statsInterval = setInterval(updateStats, 1000);

            log("‚úÖ INITIALIZATION COMPLETE");
            log("=" * 70);
        }

        // Start on load
        window.addEventListener("load", init);

        // Cleanup on unload
        window.addEventListener("beforeunload", () => {
            if (pc) pc.close();
            if (ws) ws.close();
            if (statsInterval) clearInterval(statsInterval);
        });
    </script>
</body>
</html>